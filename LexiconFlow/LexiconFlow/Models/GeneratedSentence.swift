//
//  GeneratedSentence.swift
//  LexiconFlow
//
//  AI-generated sentence examples for vocabulary learning
//

import Foundation
import SwiftData

/// An AI-generated context sentence for a flashcard
///
/// GeneratedSentence stores AI-created sentences that demonstrate
/// the usage of vocabulary words in context. Features include:
/// - 7-day TTL cache expiration for freshness
/// - CEFR level appropriateness filtering
/// - Favorite/bookmarking for best examples
/// - Source tracking (AI vs static fallback)
/// - Relationship to parent Flashcard
@Model
final class GeneratedSentence {
    /// Unique identifier for this sentence
    var id: UUID

    /// The generated sentence text showing word usage
    var sentenceText: String

    /// CEFR level estimate (A1, A2, B1, B2, C1, C2)
    var cefrLevel: String

    /// When this sentence was generated
    var generatedAt: Date

    /// When this sentence expires (7-day TTL from generatedAt)
    var expiresAt: Date

    /// Whether user has favorited/bookmarked this sentence
    var isFavorite: Bool

    /// Source of this sentence (AI-generated or static fallback)
    var source: SentenceSource

    /// The flashcard this sentence belongs to
    /// - Inverse defined on Flashcard.generatedSentences
    /// - Cascade delete: deleting flashcard removes all sentences
    @Relationship(deleteRule: .cascade) var flashcard: Flashcard?

    // MARK: - Computed Properties

    /// Whether this sentence has expired (past TTL)
    var isExpired: Bool {
        Date() > expiresAt
    }

    /// Days remaining until expiration (negative if expired)
    var daysUntilExpiration: Int {
        Calendar.current.dateComponents([.day], from: Date(), to: expiresAt).day ?? 0
    }

    // MARK: - Initialization

    /// Valid CEFR levels for validation
    private static let validCEFRLevels = Set(["A1", "A2", "B1", "B2", "C1", "C2"])

    /// Initialize a new generated sentence
    ///
    /// - Parameters:
    ///   - id: Unique identifier (defaults to new UUID)
    ///   - sentenceText: The generated sentence showing word usage
    ///   - cefrLevel: CEFR level estimate
    ///   - generatedAt: Generation timestamp (defaults to now)
    ///   - ttlDays: Time-to-live in days (defaults to 7)
    ///   - isFavorite: Whether user favorited this (defaults to false)
    ///   - source: Source of the sentence (defaults to .aiGenerated)
    ///
    /// - Throws: GeneratedSentenceError if validation fails
    init(
        id: UUID = UUID(),
        sentenceText: String,
        cefrLevel: String,
        generatedAt: Date = Date(),
        ttlDays: Int = 7,
        isFavorite: Bool = false,
        source: SentenceSource = .aiGenerated
    ) throws {
        // Validate sentence text
        guard !sentenceText.isEmpty else {
            throw GeneratedSentenceError.emptyText
        }

        // Validate CEFR level
        let normalizedLevel = cefrLevel.uppercased()
        guard Self.validCEFRLevels.contains(normalizedLevel) else {
            throw GeneratedSentenceError.invalidCEFRLevel(cefrLevel)
        }

        // Validate TTL
        guard ttlDays > 0 else {
            throw GeneratedSentenceError.invalidTTL
        }

        self.id = id
        self.sentenceText = sentenceText
        self.cefrLevel = normalizedLevel
        self.generatedAt = generatedAt
        expiresAt = Calendar.autoupdatingCurrent.date(
            byAdding: .day,
            value: ttlDays,
            to: generatedAt
        ) ?? generatedAt
        self.isFavorite = isFavorite
        self.source = source
        // flashcard relationship auto-initialized by SwiftData
    }
}

// MARK: - Sentence Source

/// Source of a generated sentence
enum SentenceSource: String, Codable, Sendable {
    /// Generated by Z.ai API
    case aiGenerated = "ai_generated"

    /// Static fallback sentence (offline mode)
    case staticFallback = "static_fallback"

    /// User-created custom sentence
    case userCreated = "user_created"
}

// MARK: - Validation Errors

/// Errors that can occur during GeneratedSentence validation
enum GeneratedSentenceError: LocalizedError, Equatable {
    case emptyText
    case invalidCEFRLevel(String)
    case invalidTTL

    var errorDescription: String? {
        switch self {
        case .emptyText:
            "Sentence text cannot be empty"
        case let .invalidCEFRLevel(level):
            "Invalid CEFR level: \(level). Must be one of: A1, A2, B1, B2, C1, C2"
        case .invalidTTL:
            "TTL must be positive (greater than 0)"
        }
    }

    var recoverySuggestion: String? {
        switch self {
        case .emptyText:
            "Provide a non-empty sentence text"
        case .invalidCEFRLevel:
            "Use a valid CEFR level (A1, A2, B1, B2, C1, or C2)"
        case .invalidTTL:
            "Specify a positive TTL value (typically 7 days)"
        }
    }
}

// MARK: - Sentence Generation Response

/// Response from sentence generation API
///
/// **nonisolated**: This type is explicitly non-isolated to allow JSON decoding
/// in actor-isolated contexts (e.g., SentenceGenerationService's nonisolated
/// decoding helper). This aligns with Swift 6 best practices for response types
/// in actor services per Matt Massicotte and Donny Wals recommendations.
nonisolated struct SentenceGenerationResponse: Codable, Sendable {
    /// Generated sentences with metadata
    let items: [GeneratedSentenceItem]

    nonisolated struct GeneratedSentenceItem: Codable, Sendable {
        /// The generated sentence text
        let sentence: String

        /// CEFR level estimate
        let cefrLevel: String

        enum CodingKeys: String, CodingKey {
            case sentence = "sentence_text"
            case cefrLevel = "cefr_level"
        }
    }
}
